
use Getopt::Long;

my %opt     = (
               max_thrd_count    => 1,
               force_max_thrds   => 0,
               force_thrd_stride => 0,
               force_multi_pids  => 0
              );

my @options =
   qw(
      max_thrd_count=i
      force_max_thrds=i
      force_thrd_stride=i
      force_multi_pids=i
     );

GetOptions(\%opt, @options);

#1/2 odds of running all thrds vs lower number of thrds
$rand_num = int(rand(2)); 
if($rand_num != 0 || $opt{force_max_thrds}) {
    $thrd_count = $opt{max_thrd_count};
}
else {
    $thrd_count = 1 + int(rand($opt{max_thrd_count}));
}

#try to spread out threads if not running at full capacity
if($opt{force_thrd_stride}) {
    $thrd_stride = $opt{force_thrd_stride};
}
else {
    $thrd_stride = int($opt{max_thrd_count}/$thrd_count);
}

:#define THREAD_COUNT  $thrd_count
:#define THREAD_STRIDE $thrd_stride

#Now pick multi-pd vs single pd
$rand_num = int(rand(2));
if($rand_num == 0 || $opt{force_multi_pids}) {
    $pid_count = 2 + int(rand(7));
}
else {
    $pid_count = 1;
}
printf("!This diag uses %d pids\n", $pid_count);

#first pick the random pid numbers
@active_pids = ();
for($i=0; $i<$pid_count; $i++) {
    my $pid = int(rand(8));
    printf("!pid included as an option : %d\n", $pid);
    push(@active_pids, $pid);
}

#then assign pid to threads
for($i=0; $i<$thrd_count; $i++) {
    my $thrd_idx = $i * $thrd_stride;
    my $pid_idx = 1 + int(rand($pid_count)); # pick a random pid

    printf("#define THR_%d_PARTID %d\n", $thrd_idx, $active_pids[$pid_idx-1]); 
}

#then assign few thread to io-stack 
:#define STACK_BASE_VA 0x68138000
:#define STACK_BASE_RA 0x178138000
:#define STACK_IOBASE_RA 0xc178038000
:#define STACKSIZE 240000

:#define USER_PAGE_CUSTOM_MAP
:#define CREGS_FPRS_FEF 1
:
:#define JBI_CONFIG
:#define CREGS_JBI_L2_TIMEOUT    0x7000000
:#define CREGS_JBI_ARB_TIMEOUT   0x1000000
:#define CREGS_JBI_TRANS_TIMEOUT 0x2000000
:
:#define ASI_Q         0x25
:#define CPU_MONDO_QH  0x3c0
:#define CPU_MONDO_QT  0x3c8
:#define DEV_MONDO_QH  0x3d0
:#define DEV_MONDO_QT  0x3d8
:#define RES_MONDO_QH  0x3e0
:#define RES_MONDO_QT  0x3e8
:#define NRES_MONDO_QH 0x3f0
:#define NRES_MONDO_QT 0x3f8
:
:#define H_HT0_Window_Spill_0_Normal_Trap spill_trap
:#define H_HT0_Window_Spill_1_Normal_Trap spill_trap
:#define H_HT0_Window_Spill_2_Normal_Trap spill_trap
:#define H_HT0_Window_Spill_3_Normal_Trap spill_trap
:#define H_HT0_Window_Spill_4_Normal_Trap spill_trap
:#define H_HT0_Window_Spill_5_Normal_Trap spill_trap
:#define H_HT0_Window_Spill_6_Normal_Trap spill_trap
:#define H_HT0_Window_Spill_7_Normal_Trap spill_trap
:
:#define H_HT0_Window_Fill_0_Normal_Trap fill_trap
:#define H_HT0_Window_Fill_1_Normal_Trap fill_trap
:#define H_HT0_Window_Fill_2_Normal_Trap fill_trap
:#define H_HT0_Window_Fill_3_Normal_Trap fill_trap
:#define H_HT0_Window_Fill_4_Normal_Trap fill_trap
:#define H_HT0_Window_Fill_5_Normal_Trap fill_trap
:#define H_HT0_Window_Fill_6_Normal_Trap fill_trap
:#define H_HT0_Window_Fill_7_Normal_Trap fill_trap
:
:#define H_T0_Cpu_Mondo_Trap_0x7c    cpu_mondo_handler
:#define H_T0_Dev_Mondo_Trap_0x7d    dev_mondo_handler
:#define H_HT0_Reserved_0x5e         hstick_cmpr_handler
:#define H_HT0_Interrupt_0x60        interrupt_handler

:#define H_HT0_Corrected_ECC_error_0x63 
:#define My_HT0_Corrected_ECC_error_0x63  retry

:#define H_HT0_HTrap_Instruction_0
:#define My_HT0_HTrap_Instruction_0   setx            init_tick_and_intr_q, %g1, %g2; \
:                                     jmp             %g2; \
:                                     nop
:
:#define H_HT0_HTrap_Instruction_1
:#define My_HT0_HTrap_Instruction_1   setx            hypv_post_diag_cleanup, %g1, %g2; \
:                                     jmp             %g2; \
:                                     nop
:
:                                  
:#include "c/template_mt.s"
:
:#ifdef USER_PAGE_CUSTOM_MAP
:SECTION .MAIN  TEXT_VA=MAIN_BASE_TEXT_VA, DATA_VA=MAIN_BASE_DATA_VA, BSS_VA=MAIN_BASE_BSS_VA
:changequote([, ])dnl
:forloop([i], 0, 7, [
:ifdef([part_]i[_used],[
:attr_text {
:        Name = .MAIN,
:        VA=MAIN_BASE_TEXT_VA,
:        RA=MAIN_BASE_TEXT_RA,
:        [part_]i[_i_ctx_nonzero_ps0_tsb],
:#ifdef MAIN_PAGE_NUCLEUS_ALSO
:        [part_]i[_i_ctx_zero_ps0_tsb],
:#endif
:#ifdef MAIN_TEXT_DATA_ALSO
:        [part_]i[_d_ctx_nonzero_ps0_tsb],
:#endif
:        PA=ra2pa2(MAIN_BASE_TEXT_RA,i),
:        TTE_G=1, TTE_Context=PCONTEXT, TTE_V=1, TTE_Size=0, TTE_NFO=0,
:        TTE_IE=0, TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:        TTE_L=0, TTE_CP=1, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=0
:        }
:
:attr_data {
:        Name = .MAIN,
:        VA=MAIN_BASE_DATA_VA,
:        RA=MAIN_BASE_DATA_RA,
:        [part_]i[_d_ctx_nonzero_ps0_tsb],
:#ifdef MAIN_PAGE_NUCLEUS_ALSO
:        [part_]i[_d_ctx_zero_ps0_tsb],
:#endif
:        PA=ra2pa2(MAIN_BASE_DATA_RA,i),
:        TTE_G=1, TTE_Context=PCONTEXT, TTE_V=1, TTE_Size=0, TTE_NFO=0,
:        TTE_IE=0, TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:        TTE_L=0, TTE_CP=1, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1
:        }
:
:attr_bss {
:        Name = .MAIN,
:        VA=MAIN_BASE_BSS_VA,
:        RA=MAIN_BASE_BSS_RA,
:        PA=ra2pa2(MAIN_BASE_BSS_RA,i),
:        [part_]i[_d_ctx_nonzero_ps0_tsb],
:        TTE_G=0, TTE_Context=PCONTEXT, TTE_V=1, TTE_Size=0, TTE_NFO=0,
:        TTE_IE=0, TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:        TTE_L=0, TTE_CP=1, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1
:        }
:])dnl
:])dnl
:changequote(`,')dnl'
:#endif
:
:#ifndef EN_WRM_RST
:#define EN_WRM_RST 0
:#endif
:#ifndef NO_SAS
:#define NO_SAS 0
:#endif
:
:MIDAS_CC FILE=mixer/mixer.c     ARGS=-O2 -S -DWRM_RST=EN_WRM_RST -DRAND_SEED=TG_SEED -DTHREAD_COUNT=THREAD_COUNT -DNO_SAS=NO_SAS -mhard-quad-float 
:MIDAS_CC FILE=lib/mtclib.c      ARGS=-O2 -S
:
:
:
:.text
:!-----------------------------------
:! %o0 : thrdid
:! %o1 : tick_cmpr_value
:!-----------------------------------
:ENTRY(init_tick_and_intr_q)
:    save    %sp, -0xc0, %sp
:
:    setx            init_tick_and_intr_q_hpv, %l0, %l1
:    jmp             %l1;
:    nop
:
:!---------------------------------------
:! returns pid
:!---------------------------------------
:ENTRY(get_pid)
:       save   %sp, -0xc0, %sp
:
:       setx            get_pid_hpv, %l0, %l1
:       jmp             %l1;
:       nop
:
:!---------------------------------------
:! returns thrdid
:!---------------------------------------
:ENTRY(get_thrdid)
:       save   %sp, -0xc0, %sp
:
:       ta     T_RD_THID
:       mov    %o1, %o0
:     
:       ret
:       restore %o0, 0, %o0
:
:!---------------------------------------
:! returns void
:!---------------------------------------
:ENTRY(itlb_invld_all)
:       save   %sp, -0xc0, %sp
:
:       setx            itlb_invld_all_hpv, %l0, %l1
:       jmp             %l1;
:       nop
:
:!---------------------------------------
:! returns void
:!---------------------------------------
:ENTRY(dtlb_invld_all)
:       save   %sp, -0xc0, %sp
:
:       setx            dtlb_invld_all_hpv, %l0, %l1
:       jmp             %l1;
:       nop
:
:!---------------------------------------
:! %i0 thrdid, %i1 num_entries
:!---------------------------------------
:ENTRY(itlb_fill_entries)
:       save   %sp, -0xc0, %sp
:
:       cmp    		%i1, 0x0
:       be		skip_fill_itlb_sec
:       nop
:
:       dec		%i1
:       setx            fill_itlb_sec0, %l0, %l1
:       jmp             %l1;
:       nop
:
:skip_fill_itlb_sec:
:	setx		itlb_fill_entries_done, %l0, %l1
:       jmp		%l1
:       nop
:
:.global itlb_fill_entries_done
:itlb_fill_entries_done:
:    ret
:    restore %g0, 0, %g0
:
:!---------------------------------------
:! %i0 thrdid, %i1 num_entries
:!---------------------------------------
:ENTRY(dtlb_fill_entries)
:       save   %sp, -0xc0, %sp
:
:       cmp    		%i1, 0x0
:       be		skip_fill_dtlb_sec
:       nop
:
:       clr		%l5  !count
:       setx            fill_dtlb_sec0, %l0, %l1
:
:loop_dtlb_fill:
:       sllx		%l5, 14, %l6 ! section offset
:       ldub            [%l1+%l6], %l2
:       cmp		%l2, %l5 
:       bne		diag_fail
:       nop
:       inc             %l5 
:       deccc		%i1  !num sections to operate
:       bne		loop_dtlb_fill
:       nop
:
:skip_fill_dtlb_sec:
:    ret
:    restore %g0, 0, %g0
:
:
:!---------------------------------------
:! %i0 src_ptr, %i1 dst_ptr, %i2 num-bytes
:!---------------------------------------
:ENTRY(memcopy)
:       save   %sp, -0xc0, %sp
:
:       membar          #Sync    ! to flush all stores before memcopy starts
:
:more_memcopy:
:       cmp    		%i2, 0x0
:       ble		memcopy_done
:       nop
:
:       ldda		[%i0]0xf0, %f0
:       stda            %f0, [%i1]0xf0
:       add             %i0, 64, %i0
:       add             %i1, 64, %i1
:       sub             %i2, 64, %i2
:       ba              more_memcopy
:       nop
:
:memcopy_done:
:       membar          #Sync   ! to flush all blk-store pkts before anybody else reads them
:
:       ret
:       restore %g0, 0, %g0
:
:
:!-----------------------------------
:! %o0 : thrdid
:! %o1 : va
:!-----------------------------------
:ENTRY(prg_strm_ma_mpa_reg)
:    save    %sp, -0xc0, %sp
:
:    setx            prg_strm_ma_mpa_reg_hpv, %l0, %l1
:    jmp             %l1;
:    nop
:
:!-----------------------------------
:! %o0 : thrdid
:! %o1 : op
:! %o2 : length
:!-----------------------------------
:ENTRY(prg_strm_ma_ctl_reg)
:    save    %sp, -0xc0, %sp
:
:    setx            prg_strm_ma_ctl_reg_hpv, %l0, %l1
:    jmp             %l1;
:    nop
:
:!-----------------------------------
:! %o0 : thrdid
:!-----------------------------------
:ENTRY(strm_ctl_busy_wait)
:    save    %sp, -0xc0, %sp
:
:    setx            strm_ctl_busy_wait_hpv, %l0, %l1
:    jmp             %l1;
:    nop
:
:!-----------------------------------
:! %o0 : thrdid
:!-----------------------------------
:ENTRY(strm_ctl_sync_wait)
:    save    %sp, -0xc0, %sp
:
:    setx            strm_ctl_sync_wait_hpv, %l0, %l1
:    jmp             %l1;
:    nop
:
:!-----------------------------------
:! %o0 : thrdid, %o1 monarch, %o2 counter_ptr
:!-----------------------------------
:ENTRY(gen_inter_proc_int_macro)
:    save    %sp, -0xc0, %sp
:
:    setx            gen_inter_proc_int_hpv, %l0, %l1
:    jmp             %l1;
:    nop
:
:!--------------------------------------------------------------------------
:!       Flush a line
:!       flush(addr)
:!--------------------------------------------------------------------------
:ENTRY(flush)
:        retl
:        flush %o0
:
:!-----------------------------------
:! %i0 : thrdid
:!-----------------------------------
:ENTRY(gen_ssi_fetch)
:    save    %sp, -0xc0, %sp
:
:    setx            gen_ssi_fetch_hpv, %l0, %l1
:    jmp             %l1;
:    nop
:
:!-----------------------------------
:! %i0 : thrdid, asi
:!-----------------------------------
:ENTRY(randomize_asi)
:    save    %sp, -0xc0, %sp
:
:    setx            randomize_asi_hpv, %l0, %l1
:    jmp             %l1;
:    nop
:
:!-----------------------------------
:! %i0 : thrdid
:!-----------------------------------
:ENTRY(gen_wrmrst)
:    save    %sp, -0xc0, %sp
:
:    setx            gen_wrmrst_hpv, %l0, %l1
:    jmp             %l1;
:    nop
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:!-----------------------------------
:ENTRY(gen_blocking_flush)
:    save    %sp, -0xc0, %sp
:    
:    clr     %l0          ! addr to flush
:
:more_blocking_flush:
:    flush   %l0
:    inc     %l0
:    flush   %l0
:    inc     %l0
:    flush   %l0
:    inc     %l0
:    flush   %l0
:    inc     %l0
:    flush   %l0
:    inc     %l0
:    flush   %l0
:    inc     %l0
:    flush   %l0
:    inc     %l0
:    flush   %l0
:    inc     %l0
:    ld      [%i1], %l1   ! blocking flag
:    cmp     %l1, 0x0
:    bne     more_blocking_flush
:    nop
:
:    ret
:    restore %g0, 0, %g0
:
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:! %i2 : prefetch_hit 
:!-----------------------------------
:ENTRY(gen_blocking_prefetch)
:    save    %sp, -0xc0, %sp
:   
:    cmp     %i2, 0x1
:    be      hit_prefetch
:    nop
:    setx    fill_dtlb_sec20, %l1, %l0
:    ba      more_blocking_prefetch
:    nop
:hit_prefetch:
:    setx    strm_unit_lock, %l1, %l0
:
:more_blocking_prefetch:
:    prefetch  [%l0], 0
:    inc        %l0
:    prefetch  [%l0], 0
:    inc        %l0
:    prefetch  [%l0], 0
:    inc        %l0
:    prefetch  [%l0], 0
:    inc        %l0
:    prefetch  [%l0], 0
:    inc        %l0
:    prefetch  [%l0], 0
:    inc        %l0
:    prefetch  [%l0], 0
:    inc        %l0
:    prefetch  [%l0], 0
:    inc        %l0
:    ld      [%i1], %l1   ! blocking flag
:    cmp     %l1, 0x0
:    bne     more_blocking_prefetch
:    nop
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:! %i2 : scratch ptr(addr to use) 
:!-----------------------------------
:ENTRY(gen_blocking_ldd)
:    save    %sp, -0xc0, %sp
:   
:    mov     %i2, %l0
:    clr     %l1
:
:more_blocking_ldd:
:    ldda  [%l0]0xf0, %f0 
:    ldda  [%l0]0xf0, %f0 
:    ldda  [%l0]0xf0, %f0 
:    ldda  [%l0]0xf0, %f0 
:    inc   %l1
:    cmp   %l1, 4
:    bl    add_to_addr
:    nop
:    mov   %i2, %l0
:    clr   %l1
:    ba    continue_exec_ldd
:    nop
:add_to_addr:
:    add   %l0, 64, %l0 
:    
:continue_exec_ldd:
:    ld      [%i1], %l2   ! blocking flag
:    cmp     %l2, 0x0
:    bne     more_blocking_ldd
:    nop
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:! %i2 : scratch ptr(addr to use) 
:!-----------------------------------
:ENTRY(gen_blocking_bls)
:    save    %sp, -0xc0, %sp
:   
:    mov     %i2, %l0
:    clr     %l1
:
:more_blocking_bls:
:    ldda  [%l0]0xf0, %f0 
:    stda  %f0, [%l0]0xf0 
:    stda  %f0, [%l0]0xf0 
:    stda  %f0, [%l0]0xf0 
:    stda  %f0, [%l0]0xf0 
:    inc   %l1
:    cmp   %l1, 4
:    bl    add_to_addr_bls
:    nop
:    mov   %i2, %l0
:    clr   %l1
:    ba    continue_exec_bls
:    nop
:add_to_addr_bls:
:    add   %l0, 64, %l0 
:    
:continue_exec_bls:
:    ld      [%i1], %l2   ! blocking flag
:    cmp     %l2, 0x0
:    bne     more_blocking_bls
:    nop
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:!-----------------------------------
:ENTRY(gen_blocking_intr)
:    save    %sp, -0xc0, %sp
:    
:    clr     %l0          ! addr to flush
:
:more_blocking_intr:
:    flush   %l0
:    inc     %l0
:    ld      [%i1], %l1   ! blocking flag
:    cmp     %l1, 0x0
:    bne     more_blocking_intr
:    nop
:
:    ret
:    restore %g0, 0, %g0
:
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:!-----------------------------------
:ENTRY(gen_blocking_icache_loop)
:    save    %sp, -0xc0, %sp
:    
:    setx    fill_dtlb_sec0, %l0, %l1
:
:more_blocking_icache_loop:
for($i=0; $i<4092; $i++) {
:    ld     [%l1], %l0
}
:    ld      [%i1], %l0   ! blocking flag
:    cmp     %l0, 0x0
:    bne     more_blocking_icache_loop
:    nop
:
:    ret
:    restore %g0, 0, %g0
:
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:!-----------------------------------
:ENTRY(gen_blocking_dcache_loop)
:    save    %sp, -0xc0, %sp
:    
:    setx    rand_numbers, %l0, %l1
:    setx    0x2000, %l0, %l2
:    add     %l1, %l2, %l1
:
:more_blocking_dcache_loop:
for($i=0; $i<512; $i++) {
$offset = $i*16;
:    ld     [%l1+$offset], %l0
}
:    ld      [%i1], %l0   ! blocking flag
:    cmp     %l0, 0x0
:    bne     more_blocking_dcache_loop
:    nop
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:!-----------------------------------
:ENTRY(gen_blocking_dcache_st_loop)
:    save    %sp, -0xc0, %sp
:    
:    setx    fill_dtlb_sec0, %l0, %l1
:
:more_blocking_dcache_st_loop:
for($i=0; $i<1000; $i++) {
:    st     %l0, [%l1+64]
}
:    ld      [%i1], %l0   ! blocking flag
:    cmp     %l0, 0x0
:    bne     more_blocking_dcache_st_loop
:    nop
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:! %i2 : ptr to cache
:!-----------------------------------
:ENTRY(gen_blocking_ex_cache_loop)
:    save    %sp, -0xc0, %sp
:    
:more_blocking_ex_cache_loop:
for($i=0; $i<128; $i++) {
$offset = $i*32;
:    ld     [%i2+$offset], %g0
}
:    ld      [%i1], %l0   ! blocking flag
:    cmp     %l0, 0x0
:    bne     more_blocking_ex_cache_loop
:    nop
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:!-----------------------------------
:ENTRY(gen_blocking_self_cache_loop)
:    save    %sp, -0xc0, %sp
:    
:    setx    more_blocking_self_cache_loop, %l0, %l1
:
:more_blocking_self_cache_loop:
for($i=0; $i<32; $i++) {
$offset = $i*4;
:    ld     [%l1+$offset], %l0
}
:    ld      [%i1], %l0   ! blocking flag
:    cmp     %l0, 0x0
:    bne     more_blocking_self_cache_loop
:    nop
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : blocking_req ptr
:!-----------------------------------
:ENTRY(gen_blocking_self2_cache_loop)
:    save    %sp, -0xc0, %sp
:
:    setx    more_blocking_self2_cache_loop, %l0, %l1
:    jmpl    %l1, %g0
:    nop
:
:.align 32
:more_blocking_self2_cache_loop:
for($i=0; $i<20; $i++) {
$ld_offset   = ($i*64) + 80;
$jmp_offset  = ($i*64) + 72;
$jmp1_offset = ($i*64) + 32;
:    nop;nop
:    ld     [%l1+$ld_offset], %l0
:    nop
if($i < 19) {
:    jmpl   %l1+$jmp_offset, %g0
:    jmpl   %l1+$jmp1_offset, %g0
:    nop; nop;
}
:    nop;nop;nop;nop
:    nop;nop;nop;nop
}
:
:    ld      [%i1], %l0   ! blocking flag
:    cmp     %l0, 0x0
:    bne     more_blocking_self2_cache_loop
:    nop
:
:    ret
:    restore %g0, 0, %g0
:

:
:!-----------------------------------
:! %i0 : opcode
:! %i1 : rs1
:! %i2 : rs1_val
:! %i3 : rs2
:! %i4 : rs2_val
:!-----------------------------------
:ENTRY(execute_inst)
:    save    %sp, -0xc0, %sp
:
:    ta      T_RD_THID
:    setx    generated_text_t0, %l0, %l1
:    sllx    %o1, 6, %l0  ! gives an offset in generated_text_t
:    stuw    %i0, [%l1+%l0]
:    flush   %l1+%l0
: 
:    add     %l1, %l0, %o0 ! target jmp addr
:    mov     %i1, %o1
:    mov     %i2, %o2
:    mov     %i3, %o3
:    mov     %i4, %o4
:    save    %sp, -0xc0, %sp
:
:    jmp     %i0
:    nop
:
:    retl
:    restore
:
:
for ($thr = 0; $thr < 4; $thr++) {
    printf("th_main_%d:\n", $thr*4);
:   !mov 0x20*$thr, %l0
:   !add %l0, 0x100, %l0
:   !ta T_HTRAP_INST0             ! program hstick reg to generate interrupts.
    for($i=0; $i < 0x40; $i++) { # wait time, but use sync instead.
:       nop
    }
    for ($i = 0; $i < 0x40; $i++) {
        printf("stress_marker_A%d_%d:", $i, $thr);
        if($i == 0) {
:           nop
        }
        elsif($i == 0x1) {
:           nop
        }
        elsif($i == 0x2) {
:           nop 
        }
        else {
:           setx garbage_area1, %l0, %l1
:           st   %g0, [%l1]
:           flush %l1
:           setx garbage_area2, %l0, %l1
:           flush %l1
:           setx garbage_area3, %l0, %l1
:           flush %l1
:           setx garbage_area4, %l0, %l1
:           st   %g0, [%l1]
:           flush %l1
        }
        if($i%2 == 1) {
            printf("setx 0x%x, %l0, %l1\n", ((((4*$thr+4)%16) << 8) | $i));
:           setx  generate_cpu_intr, %l0, %l2
:           jmpl  %l2, %o7
:           nop
        }
        else 
        {
            printf("! \$EV trig_pc_d \(1,\@VA\(.MAIN.stress_marker_A%d_%d\)\) -> intp\(%x, 0, %x\)\n", $i, $thr, ((4*$thr+4)%16), $i);
        }
    }
:   setx barrier_count, %l0, %l1 ! check that we are fine on interrupt count.
:   setx 0x40, %l0, %l2
: wait_for_all_intr_$thr:
:   ldub  [%l1+$thr], %l3
:   cmp %l2, %l3
:   bne wait_for_all_intr_$thr
:   nop
:   setx intr_vec_flags, %l0, %l1     ! check that all flags are set.
:   setx 0xffffffffffffffff, %l0, %l2
    printf("   ldx \[\%l1 + ");
    printf("%d", $thr*8);
    printf("], \%l3\n"); 
:   cmp %l2, %l3
:   bne diag_fail
:   nop
:   ta T_HTRAP_INST1                  ! shutup the tick-cmpr before good-trap
:   ba diag_pass
:   nop
}
:nop
:
:/*
: ********************************
: *      Diag PASSED             *
: ********************************
: */
:diag_pass:
:        ta T_GOOD_TRAP
:        nop
:
:/*
: ********************************
: *      Diag FAILED !           *
: ********************************
: */
:diag_fail:
:        ta T_BAD_TRAP
:        nop
:        nop
:
:                             
$jal_file_root = "$ENV{DV_ROOT}/verif/diag/assembly/random/jal/mixer";
$raw_file_root = "$ENV{DV_ROOT}/verif/diag/assembly/raw_random";
$jal_files_str = `ls -m $jal_file_root/*.j`;
@jal_files     = split(/\,/, $jal_files_str);
$indra_macro_count = 0;
system("mkdir $ENV{PWD}/indra_build") if(!-d "$ENV{PWD}/indra_build");
foreach $jal_file (@jal_files) {
    $jal_file =~ s/^\n?(.*)\n?$/$1/g;
    $prefix   = $1 if($jal_file =~ /.*\/(.*)\.j$/);
    $postfix  = int(rand(100000));
    $diagdir  = $prefix."_".$postfix;
    $diagname = $diagdir."_rand_0.s";

    system("cp $jal_file_root/$prefix.j $ENV{PWD}/indra_build/.");
    system("touch $ENV{PWD}/indra_build/bg_mem.image");
    $indra_out = `cd $ENV{PWD}/indra_build; indra -t=500 -c=1 -p=$diagdir -D=FUNC_NAME=indra_rand_$indra_macro_count $prefix.j; cd -`;
    system("cp $raw_file_root/$diagdir/$diagname .");
    system("rm -rf $raw_file_root/$diagdir") if(-d "$raw_file_root/$diagdir");

:#include "./$diagname"

    $indra_macro_count++;
}
:
:.data
:.global indra_macros_start
:.global indra_macros_end
:indra_macros_start:
for($i=0; $i<$indra_macro_count; $i++) {
:.xword indra_rand_$i
}
:indra_macros_end:
:.xword 0x0





:SECTION .HYP_SEC TEXT_VA=0x1e03006000, DATA_VA=0x1e03008000
:attr_text {
:	Name=.HYP_SEC,
:	hypervisor
:}
:attr_data {
:	Name=.HYP_SEC,
:	hypervisor
:}
:changequote([, ])dnl
:forloop([i], 0, 7, [
:ifdef([part_]i[_used],[
:attr_text {
:        Name = .HYP_SEC,
:        VA=0x1e03006000,
:        RA=[0x]mpeval(0xe03006000 - i * 2 * 0x100000000, 16),
:        tsbonly,
:        [part_]i[_i_ctx_zero_ps0_tsb],
:        [part_]i[_i_ctx_nonzero_ps0_tsb],
:        [part_]i[_d_ctx_zero_ps0_tsb],
:        [part_]i[_d_ctx_nonzero_ps0_tsb],
:        TTE_G=0, TTE_Context=PCONTEXT, TTE_V=1, TTE_Size=0, TTE_NFO=0,
:        TTE_IE=[[0-1]], TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:        TTE_L=0, TTE_CP=1, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1
:        }
:attr_data {
:        Name = .HYP_SEC,
:        VA=  0x1e03008000,
:        RA=[0x]mpeval(0xe03008000 - i * 2 * 0x100000000, 16),
:        tsbonly,
:        [part_]i[_d_ctx_zero_ps0_tsb],
:        [part_]i[_d_ctx_nonzero_ps0_tsb],
:        TTE_G=0, TTE_Context=PCONTEXT, TTE_V=1, TTE_Size=0, TTE_NFO=0,
:        TTE_IE=0, TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:        TTE_L=0, TTE_CP=1, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1
:        }
:])dnl
:])dnl
:changequote(`,')dnl'
:
:.text
:.global interrupt_handler
:.global hstick_cmpr_handler
:.global cpu_mondo_handler
:.global dev_mondo_handler
:.global generate_cpu_intr
:.global hypv_post_diag_cleanup
:.global garbage_area1
:.global garbage_area2
:.global garbage_area3
:.global garbage_area4
:.global garbage_area5
:
:garbage_area1:
:	.word  0xffffffff
:
:interrupt_handler:      
:        ldxa  [ %g0 ] 0x74, %g1                 ! %g1 read interrupt vector from ASI_UDB_INTR_R
:        and   %g1, 0x1f, %g2                    ! %g2 thrdid of proc who sent interrupt
:
:        setx      inter_proc_int_ctr, %g7, %g3  ! %g3 has the addr of counter
:        ldub [%g3+%g2], %g4                     ! %g4 new value of counter
:
:        and   %g1, 0x20, %g5
:        cmp   %g5, 0x20
:        bne   check_proc_int_ctr
:        nop
:
:    cache_proc_int_ctr:
:        retry
:
:    check_proc_int_ctr:
:        setx last_inter_proc_int_ctr, %g1, %g5   ! %g5 has the addr of counter previous
:        lduba [%g5+%g2] 0x10, %g6                ! %g6 old value, seen last time
:        cmp %g4, %g6
:        tle T_BAD_TRAP
:        stba %g4, [%g5+%g2] 0x10                 ! store to last copy
:        retry
:
:garbage_area2:
:	.word  0xffffffff
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : tick_cmpr_value
:!-----------------------------------
:ENTRY(init_tick_and_intr_q_hpv)
:    ta      T_CHANGE_HPRIV
:    wr      %g0, 0x0, %sys_tick
:    wrhpr   %g0, %i1, %hsys_tick_cmpr
:    mov     DEV_MONDO_QH, %g6         ! init head ptr
:    stxa    %g0, [%g6]ASI_Q
:    mov     DEV_MONDO_QT, %g6         ! init tail ptr
:    stxa    %g0, [%g6]ASI_Q
:    mov     0x40, %g1
:    mov     CPU_MONDO_QH, %g6         ! init head ptr
:    stxa    %g1, [%g6]ASI_Q
:    mov     CPU_MONDO_QT, %g6         ! init tail ptr
:    stxa    %g1, [%g6]ASI_Q
:    ta      T_CHANGE_NONHPRIV
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : tick_cmpr_value
:!-----------------------------------
:ENTRY(get_pid_hpv)
:    ta      T_CHANGE_HPRIV
:    mov     0x80, %l0
:    ldxa    [%l0]0x58, %o0
:    ta      T_CHANGE_NONHPRIV
:
:    ret
:    restore %o0, 0, %o0
:
:!-----------------------------------
:!-----------------------------------
:ENTRY(itlb_invld_all_hpv)
:    ta      T_CHANGE_HPRIV
:    stxa    %g0, [%g0] 0x60
:    ta      T_CHANGE_NONHPRIV
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:!-----------------------------------
:ENTRY(dtlb_invld_all_hpv)
:    ta      T_CHANGE_HPRIV
:    mov     0x8, %l0
:    stxa    %g0, [%l0] 0x60
:    ta      T_CHANGE_NONHPRIV
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:ENTRY(randomize_asi_hpv)
:    ta      T_CHANGE_HPRIV
:    wr      %g0, %i1, %asi 
:    ta      T_CHANGE_NONHPRIV
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:!-----------------------------------
:ENTRY(gen_wrmrst_hpv)
:
:    ta      T_CHANGE_HPRIV
:    setx    0x9600000000, %l1, %l2
:
:    ! Set DRAM self-refresh bit
:    setx    0x2000000000000000, %l1, %l3
:    ldx     [%l2 + 0x08], %l1
:    or      %l3, %l1, %l3
:    stx     %l3, [%l2 + 0x08]
:    ldx     [%l2 + 0x08], %l1
:    ta      T_CHANGE_NONHPRIV
:    cmp     %i1, 0x0
:    be      wrmrst_disabled
:    nop
:
:gen_warm_rst_lbl:
:    nop    !\$EV  trig_pc_d(1, \@VA(.HYP_SEC.gen_warm_rst_lbl)) -> warmrst()            
:    nop
:
:wrmrst_disabled:
:
:    ret
:    restore %o0, 0, %o0
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : va
:!-----------------------------------
:ENTRY(prg_strm_ma_mpa_reg_hpv)
:    ta      T_CHANGE_HPRIV
:    setx    MAIN_BASE_DATA_VA, %l0, %l1
:    sub     %i1, %l1, %l1                   ! %l1: offset into the stack
:    setx    MAIN_BASE_DATA_RA, %l0, %l2
:    add     %l1, %l2, %l1                   ! %l1: RA+offset. 
:    mov     0x80, %l0
:    ldxa    [%l0] 0x58, %l2                 ! %l2: PID 
:    mulx    %l2, 8, %l2                     ! offset in part-base-list
:    setx    partition_base_list, %l0, %l3   ! %l3: part-base
:    ldx     [%l3+%l2], %l4                  ! %l4: partition-base
:    add     %l4, %l1, %l1                   ! The PA
:    mov     0x88, %l0
:    stxa    %l1, [%l0] 0x40                 ! Program PA in strm_ma_mpa
:    mov     0x90, %l0
:    stxa    %g0, [%l0] 0x40                 ! Program offset in ma-addr-reg 
:    ta      T_CHANGE_NONHPRIV
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:! %i1 : op
:! %i2 : length
:!-----------------------------------
:ENTRY(prg_strm_ma_ctl_reg_hpv)
:    ta      T_CHANGE_HPRIV
:    !mov     0x80, %l0
:    !ldxa    [%l0] 0x40, %l1                 ! %l1: strm-ctl, initial value
:    and     %i2, 0x3f, %l2                  ! %l2: length 
:    and     %i1,  0x7, %l3                  ! %l3: op
:    and     %i0,  0x3, %l4                  ! %l4: thrid on core.
:
:    sllx    %l4, 11,  %l5                   ! %l5: tmp-strm-ctl
:    sllx    %l3,  6,  %l3
:    or      %l5, %l3, %l5
:    or      %l5, %l2, %l5
:    
:    mov     0x80, %l0
:    stxa    %l5, [%l0] 0x40                 ! %l1: strm-ctl, initial value
:    ta      T_CHANGE_NONHPRIV
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:!-----------------------------------
:ENTRY(strm_ctl_busy_wait_hpv)
:    ta      T_CHANGE_HPRIV
:    mov     0x80, %l0
:strm_ctl_busy:
:    ldxa    [%l0] 0x40, %l1                 ! %l1: strm-ctl, initial value
:
:    srlx    %l1, 10,  %l1
:    or      %l1, 0x1, %l1
:    brnz    %l1, strm_ctl_busy
:    nop
:
:    ta      T_CHANGE_NONHPRIV
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:!-----------------------------------
:ENTRY(strm_ctl_sync_wait_hpv)
:    ta      T_CHANGE_HPRIV
:    mov     0xa0, %l0
:    ldxa    [%l0] 0x40, %l1                 ! %l1: strm-ctl, initial value
:
:    ta      T_CHANGE_NONHPRIV
:
:    ret
:    restore %g0, 0, %g0
:
:!-----------------------------------
:! %i0 : thrdid
:!-----------------------------------
:ENTRY(gen_inter_proc_int_hpv)
:    ta      T_CHANGE_HPRIV
:    
:    setx       inter_proc_int_ctr, %l1, %l6
:    setx  last_inter_proc_int_ctr, %l1, %l7
:  wait_for_prev_sync:
:    ldub  [%l6+%i0],      %l1
:    lduba [%l7+%i0] 0x10, %l2
:    cmp   %l1, %l2
:    bne wait_for_prev_sync
:    nop
:
:    sllx  %i1,   8, %i1                     ! send intr to monarch
:    or    %i0, %i1, %i1                     ! with a vector of my-thrdid
:    or    %i1, 0x20, %i1                    ! prepare vector {0x1, my-thrdid} indicating check-message
:    stxa  %i1, [%g0] 0x73                   ! send an indication that interrupt is coming
:    xor   %i1, 0x20, %i1                    ! prepare vector {0x0, my-thrdid} indicating check-message
:
:    ta      T_CHANGE_NONHPRIV               ! just for delay
:    setx    fill_dtlb_sec0, %o0, %o1
:    ldub    [%o1], %g0
:    setx    fill_dtlb_sec1, %o0, %o1
:    ldub    [%o1], %g0
:    ta      T_CHANGE_HPRIV                  ! just for delay
:
:    inc   %l1
:    stb   %l1, [%l6+%i0]
:    stxa  %i1, [%g0] 0x73                   ! send an interrupt for value check 
:
:    ta      T_CHANGE_NONHPRIV
:
:    ret
:    restore %g0, 0, %g0
:
:hstick_cmpr_handler:
:       setx   register_tick_cmpr_event, %g1, %g2
:       jmpl   %g2, %g7
:       nop
:
:       rdhpr  %hsys_tick_cmpr, %g1 
:	add   %g1, 0x7FF, %g1               ! fix this once sas is fixed.
:       wrhpr  %g1, %g0, %hsys_tick_cmpr
:	wrhpr  0, %hintp                   ! turnoff hintp before going in user mode(C-main).
:
:       restore 
:
:       retry
:
:garbage_area3:
:	.word  0xffffffff
:
:cpu_mondo_handler:
:        ta T_RD_THID                  ! %o1 gets thrd_id
:	 udivx %o1, THREAD_STRIDE, %o1
:
:	 mov CPU_MONDO_QT, %g6         ! look at dev_mondo tail
:        ldxa [%g6]ASI_Q, %g1
:	 mov CPU_MONDO_QH, %g6         ! look at dev_mondo head
:        ldxa [%g6]ASI_Q, %g2
:        cmp %g1, %g2
:        tle T_BAD_TRAP
:
:	 srlx %g2, 4, %g2              ! adjust ptr for right word
:	 setx mondo_data, %g7, %g6
:	 add  %g6, %o1, %g6
:        ldub [%g6+%g2], %g3           ! check to see if this was pending
:        cmp %g3, 0x1
:        tne T_BAD_TRAP
:        inc %g3
:        stub %g3, [%g6+%g2]           ! store back serviced dev-mondo signature
:
:	 mov CPU_MONDO_QH, %g6         ! look at dev_mondo head
:        ldxa [%g6]ASI_Q, %g2
:        add %g2,0x80,%g2             ! increment the head ptr now
:        stxa %g2,[%g6]ASI_Q
:        retry
:
:
:dev_mondo_handler:
:        ta T_RD_THID                  ! %o1 gets thrd_id
:	 udivx %o1, THREAD_STRIDE, %o1
:
:	 mov DEV_MONDO_QT, %g6         ! look at dev_mondo tail
:        ldxa [%g6]ASI_Q, %g1
:	 mov DEV_MONDO_QH, %g6         ! look at dev_mondo head
:        ldxa [%g6]ASI_Q, %g2
:        cmp %g1, %g2
:        tle T_BAD_TRAP
:
:	 srlx %g2, 4, %g2              ! adjust ptr for right word
:	 setx mondo_data, %g7, %g6
:	 add  %g6, %o1, %g6
:        ldub [%g6+%g2], %g3           ! check to see if this was pending
:        cmp %g3, 0x1
:        tne T_BAD_TRAP
:        inc %g3
:        stub %g3, [%g6+%g2]           ! store back serviced dev-mondo signature
:
:	 mov DEV_MONDO_QH, %g6         ! look at dev_mondo head
:        ldxa [%g6]ASI_Q, %g2
:        add %g2,0x80,%g2             ! increment the head ptr now
:        stxa %g2,[%g6]ASI_Q
:        retry
:
:garbage_area4:
:	.word  0xffffffff
:
:generate_cpu_intr:
:        ta T_CHANGE_HPRIV         
:        stxa  %l1, [%g0] 0x73
:        ta T_CHANGE_NONHPRIV
:        jmp %o7+8                       ! return to calling addr
:        nop
:
:garbage_area5:
:	.word  0xffffffff
:
:hypv_post_diag_cleanup:
:        wrhpr           %g0, 0x100, %hsys_tick_cmpr
:        done
:
for($i=0; $i<32; $i++) {
:.global generated_text_t$i
:generated_text_t$i:
:.word 0x0
:retl
:restore
:.xword 0x0
:.xword 0x0
:.xword 0x0
}
:
:
:.data
:.global barrier_count
:.global intr_vec_flags
:barrier_count:
:.word 0x0
:
:.align 8
:intr_vec_flags:
:.xword 0x0
:.xword 0x0
:.xword 0x0
:.xword 0x0
:
:.align 256 
:mondo_data:
for($i=0; $i<64; $i++) {
:.word 0x0
}
:
:.global finish_mask
:.global finish_mask_lock
:.align 4
:finish_mask:
:  .word 0
:finish_mask_lock:
:  .word 0
:
:.global strm_unit_use_mask
:.global strm_unit_lock
:.align 4
:strm_unit_use_mask:
:  .word 0
:strm_unit_lock:
:  .word 0
:
:
:
:.global common_counter
:common_counter:
:.xword 0
:.xword 0
:.xword 0
:.xword 0

:.align 4
:.global inter_proc_int_ctr
:inter_proc_int_ctr:
:.xword 0
:.xword 0
:.xword 0
:.xword 0

:.align 64
:.global mem_dma_scratch
:mem_dma_scratch:
for($i=0; $i<8192; $i++) {
:.word 0x[[0-0xffffffff]]
}

:SECTION .JBUS4_IO_SEC DATA_VA=0xc000000000
:attr_data {
:	Name=.JBUS4_IO_SEC,
:	hypervisor
:}
:changequote([, ])dnl
:forloop([i], 0, 7, [
:ifdef([part_]i[_used],[
:attr_data {
:       Name = .JBUS4_IO_SEC,
:       VA=0xc000000000,
:       RA=0xc000000000,
:       tsbonly,
:       [part_]i[_d_ctx_zero_ps0_tsb],
:       [part_]i[_d_ctx_nonzero_ps0_tsb],
:       TTE_Context=PCONTEXT, TTE_G=1, TTE_Size=0x0, TTE_NFO=0,
:       TTE_IE=[[0-1]], TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:       TTE_L=0, TTE_CP=0, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1,  TTE_V=1
:       }
:])dnl
:])dnl
:changequote(`,')dnl'
:
:.global jbus4_io_src1_arr
:.global jbus4_io_src2_arr
:.global jbus4_io_dst_arr
:.global jbus4_io_scratch
:.data
:jbus4_io_src1_arr:
:.skip 8192
:jbus4_io_src2_arr:
:.skip 8192
:jbus4_io_dst_arr:
:.skip 8192
:.align 64
:jbus4_io_scratch:
for($i=0; $i<8192; $i++) {
:.word 0x[[0-0xffffffff]]
}



:SECTION .JBUS5_IO_SEC DATA_VA=0xef00000000
:attr_data {
:	Name=.JBUS5_IO_SEC,
:	hypervisor
:}
:changequote([, ])dnl
:forloop([i], 0, 7, [
:ifdef([part_]i[_used],[
:attr_data {
:       Name = .JBUS5_IO_SEC,
:       VA=0xef00000000,
:       RA=0xef00000000,
:       tsbonly,
:       [part_]i[_d_ctx_zero_ps0_tsb],
:       [part_]i[_d_ctx_nonzero_ps0_tsb],
:       TTE_Context=PCONTEXT, TTE_G=1, TTE_Size=0x0, TTE_NFO=0,
:       TTE_IE=[[0-1]], TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:       TTE_L=0, TTE_CP=0, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1,  TTE_V=1
:       }
:])dnl
:])dnl
:changequote(`,')dnl'
:
:.global jbus5_io_src1_arr
:.global jbus5_io_src2_arr
:.global jbus5_io_dst_arr
:.global jbus5_io_scratch
:.data
:jbus5_io_src1_arr:
:.skip 8192
:jbus5_io_src2_arr:
:.skip 8192
:jbus5_io_dst_arr:
:.skip 8192
:.align 64
:jbus5_io_scratch:
for($i=0; $i<8192; $i++) {
:.word 0x[[0-0xffffffff]]
}


:SECTION .JBUS_FAKE_DMA_SEC DATA_VA=0x80e0000000
:attr_data {
:	Name=.JBUS_FAKE_DMA_SEC,
:	hypervisor
:}
:changequote([, ])dnl
:forloop([i], 0, 7, [
:ifdef([part_]i[_used],[
:attr_data {
:       Name = .JBUS_FAKE_DMA_SEC,
:       VA=0x80e0000000,
:       RA=0x80e0000000,
:       tsbonly,
:       [part_]i[_d_ctx_zero_ps0_tsb],
:       [part_]i[_d_ctx_nonzero_ps0_tsb],
:       TTE_Context=PCONTEXT, TTE_G=1, TTE_Size=0x0, TTE_NFO=0,
:       TTE_IE=[[0-1]], TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:       TTE_L=0, TTE_CP=0, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1,  TTE_V=1
:       }
:])dnl
:])dnl
:changequote(`,')dnl'
:
:.global jbus_fake_dma_src1_arr
:.global jbus_fake_dma_src2_arr
:.global jbus_fake_dma_dst_arr
:.global jbus_fake_dma_scratch
:.data
:jbus_fake_dma_src1_arr:
:.skip 8192
:jbus_fake_dma_src2_arr:
:.skip 8192
:jbus_fake_dma_dst_arr:
:.skip 8192
:.align 64
:jbus_fake_dma_scratch:
for($i=0; $i<8192; $i++) {
:.word 0x[[0-0xffffffff]]
}


:SECTION .MEM_FAKE_DMA_SEC DATA_VA=0x00e0000000
:attr_data {
:	Name=.MEM_FAKE_DMA_SEC,
:	hypervisor
:}
:changequote([, ])dnl
:forloop([i], 0, 7, [
:ifdef([part_]i[_used],[
:attr_data {
:       Name = .MEM_FAKE_DMA_SEC,
:       VA=0x00e0000000,
:       RA=0x00e0000000,
:       tsbonly,
:       [part_]i[_d_ctx_zero_ps0_tsb],
:       [part_]i[_d_ctx_nonzero_ps0_tsb],
:       TTE_Context=PCONTEXT, TTE_G=1, TTE_Size=0x0, TTE_NFO=0,
:       TTE_IE=[[0-1]], TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:       TTE_L=0, TTE_CP=1, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1,  TTE_V=1
:       }
:])dnl
:])dnl
:changequote(`,')dnl'
:
:.global mem_fake_dma_src1_arr
:.global mem_fake_dma_src2_arr
:.global mem_fake_dma_dst_arr
:.global mem_fake_dma_scratch
:.data
:mem_fake_dma_src1_arr:
:.skip 8192
:mem_fake_dma_src2_arr:
:.skip 8192
:mem_fake_dma_dst_arr:
:.skip 8192
:.align 64
:mem_fake_dma_scratch:
for($i=0; $i<8192; $i++) {
:.word 0x[[0-0xffffffff]]
}


:SECTION .SSI_IO_SEC TEXT_VA=0xfffc000000, DATA_VA=0xfff8000000
:attr_text {
:	Name=.SSI_IO_SEC,
:	hypervisor
:}
:attr_data {
:	Name=.SSI_IO_SEC,
:	hypervisor
:}
:changequote([, ])dnl
:forloop([i], 0, 7, [
:ifdef([part_]i[_used],[
:attr_text {
:       Name = .SSI_IO_SEC,
:       VA=0xfffc000000,
:       RA=0xfffc000000,
:       tsbonly,
:       [part_]i[_i_ctx_zero_ps0_tsb],
:       [part_]i[_i_ctx_nonzero_ps0_tsb],
:       TTE_Context=PCONTEXT, TTE_G=1, TTE_Size=0x0, TTE_NFO=0,
:       TTE_IE=[[0-1]], TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:       TTE_L=0, TTE_CP=0, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1,  TTE_V=1
:       }
:attr_data {
:       Name = .SSI_IO_SEC,
:       VA=0xfff8000000,
:       RA=0xfff8000000,
:       tsbonly,
:       [part_]i[_d_ctx_zero_ps0_tsb],
:       [part_]i[_d_ctx_nonzero_ps0_tsb],
:       TTE_Context=PCONTEXT, TTE_G=1, TTE_Size=0x0, TTE_NFO=0,
:       TTE_IE=[[0-1]], TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:       TTE_L=0, TTE_CP=0, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1,  TTE_V=1
:       }
:])dnl
:])dnl
:changequote(`,')dnl'
:
:.text
:!-----------------------------------
:! %i0 : thrdid
:!-----------------------------------
:ENTRY(gen_ssi_fetch_hpv)
:
:    ret
:    restore %o0, 0, %o0
:
:
:.data
:.global ssi_io_src1_arr
:.global ssi_io_src2_arr
:.global ssi_io_dst_arr
:ssi_io_src1_arr:
:.skip 8192
:ssi_io_src2_arr:
:.skip 8192
:ssi_io_dst_arr:
:.skip 8192


:SECTION .HYP_SEC
:.data
:.global rand_numbers
:rand_numbers:
for($i=0; $i<10000; $i++) {
:.word 0x[[0-0xffffffff]]
}


for($i=0; $i<100; $i++) {
$text_va = 0xf0000000 + ((2*$i)  *0x2000);
$data_va = 0xf0000000 + ((2*$i+1)*0x2000);
$j = ($i+1)%100;

:SECTION .FILL_TLB$i  TEXT_VA=$text_va, DATA_VA=$data_va
:changequote([, ])dnl
:forloop([i], 0, 7, [
:ifdef([part_]i[_used],[
:attr_text {
:        Name = .FILL_TLB$i,
printf("        VA=0x%x,\n",$text_va);
printf("        RA=0x%x,\n",$text_va);
:        [part_]i[_i_ctx_nonzero_ps0_tsb],
:#ifdef MAIN_PAGE_NUCLEUS_ALSO
:        [part_]i[_i_ctx_zero_ps0_tsb],
:#endif
:#ifdef MAIN_TEXT_DATA_ALSO
:        [part_]i[_d_ctx_nonzero_ps0_tsb],
:#endif
:        PA=ra2pa2($text_va,i),
:        TTE_G=1, TTE_Context=PCONTEXT, TTE_V=1, TTE_Size=0, TTE_NFO=0,
:        TTE_IE=[[0-1]], TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:        TTE_L=0, TTE_CP=1, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=0
:        }
:
:attr_data {
:        Name = .FILL_TLB$i,
printf("        VA=0x%x,\n",$data_va);
printf("        RA=0x%x,\n",$data_va);
:        [part_]i[_d_ctx_nonzero_ps0_tsb],
:#ifdef MAIN_PAGE_NUCLEUS_ALSO
:        [part_]i[_d_ctx_zero_ps0_tsb],
:#endif
:        PA=ra2pa2($data_va,i),
:        TTE_G=1, TTE_Context=PCONTEXT, TTE_V=1, TTE_Size=0, TTE_NFO=0,
:        TTE_IE=[[0-1]], TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:        TTE_L=0, TTE_CP=1, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1
:        }
:])dnl
:])dnl
:changequote(`,')dnl'
:
:.text
:.global fill_itlb_sec$i
:fill_itlb_sec$i:
:       cmp    		%i1, 0x0
:       be		skip_fill_itlb_sec
:       nop
:
:       dec		%i1
:       setx            fill_itlb_sec$j, %l0, %l1
:       jmp             %l1;
:       nop
:
:skip_fill_itlb_sec:
:	setx		itlb_fill_entries_done, %l0, %l1
:       jmp		%l1
:       nop
:
:.data
:.global fill_dtlb_sec$i
:fill_dtlb_sec$i:
:.byte $i
:.xword 0x12345678
:
}


for($i=0; $i<$thrd_count; $i++) {
    my $thrd_idx = $i * $thrd_stride;
    my $io_stack  = [[0-3]]; # pick io-stack 

:changequote([, ])dnl
:SECTION .STACK$thrd_idx BSS_VA= [0x]mpeval(STACK_BASE_VA + $thrd_idx * USER_PAGE_INCR, 16)
:attr_bss {
:        NAME=.STACK$thrd_idx,
:        VA=[0x]mpeval(STACK_BASE_VA + $thrd_idx * USER_PAGE_INCR, 16),

    if($io_stack == 0) {
:        RA=[0x]mpeval(STACK_IOBASE_RA + $thrd_idx * USER_PAGE_INCR, 16),
:        PA=[0x]mpeval(STACK_IOBASE_RA + $thrd_idx * USER_PAGE_INCR, 16),
    }
    else {
:        RA=[0x]mpeval(STACK_BASE_RA + $thrd_idx * USER_PAGE_INCR, 16),
:        PA=ra2pa2([0x]mpeval(STACK_BASE_RA + $thrd_idx * USER_PAGE_INCR, 16), tid2pid($thrd_idx)),
    }
:        [part_]tid2pid($thrd_idx)[_d_ctx_nonzero_ps0_tsb],
:        TTE_G=1, TTE_Context=PCONTEXT,
:        TTE_V=1, TTE_Size=PART0_D_NZ_PS0_PAGE_SIZE, TTE_NFO=0,
:        TTE_IE=[[0-1]], TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:        TTE_L=0, TTE_CP=1, TTE_CV=0, TTE_E=0, TTE_P=0, TTE_W=1
:        }
:.section .bss
:.global stack$thrd_idx
:stack$thrd_idx:
:        .skip STACKSIZE
:changequote(`,')dnl'
} #thrd_count

:SECTION .MAIN
:.data
:.global last_inter_proc_int_ctr
:.global rand

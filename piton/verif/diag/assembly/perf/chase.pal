# -*- perl -*-

# PAL script for creating pointer-chasing diags

use strict;
use Getopt::Long;
use Pod::Usage;

use TRELoad 'BitFieldTie';

my %opt     = (
	       chasefunc => 'chase',
	       lenbytes  => 8192,
	       stride    => 16,
	       startva   =>   '0x100000',
	       startra   => '0x10100000',
	       partition => 0,
	       pagesize  => 0,
	       offset    => 0,

	       check     => 1,
	       warmup    => 1,
	       disablel1_warmup => 1,
	       warmup_loopback => 0,
	       flush_dtlb => 0,
	       tolerance => 0,
	      );
my @options =
   qw(
      h
      startva=s
      startra=s
      startpa=s
      chasefunc=s
      lenbytes=s
      stride=s
      pagesize=s
      partition=i
      offset=s

      expect_time=i
      expect_string=s
      tolerance=f
      check!

      warmup!
      disablel1_warmup!
      warmup_loopback!
      flush_dtlb!
     );

GetOptions(\%opt, @options) or pod2usage(-exitval => -1, -verbose => 1);
pod2usage(-exitval => 0, -verbose => 2) if $opt{h};

:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
:!
:! Auto-generated from chase.pal
:! DO NOT EDIT THIS FILE!
:! -lenbytes $opt{lenbytes}
:! -stride $opt{stride}
:! -pagesize $opt{pagesize}
:! -partition $opt{partition}
:!
:! -flush_dtlb = $opt{flush_dtlb}
:! -offset = $opt{offset}
:!
:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
:
:


$opt{lenbytes} = spec_to_int($opt{lenbytes}, 'lenbytes');
$opt{stride}   = spec_to_int($opt{stride}, 'stride');
$opt{offset}   = spec_to_int($opt{offset}, 'offset');

if($opt{offset} >= $opt{stride}) {
  pod2usage(-exitval => 2,
	    -message =>
	    "Offset ($opt{offset}) >= stride ($opt{stride}).",
	    -verbose => 1);
}

if($opt{pagesize} =~ /^8[kK][bB]?$/) {
  $opt{pagesize} = 0;
} elsif($opt{pagesize} =~ /^64[kK][bB]?$/) {
  $opt{pagesize} = 1;
} elsif($opt{pagesize} =~ /^4[mM][bB]?$/) {
  $opt{pagesize} = 3;
} elsif($opt{pagesize} =~ /^256[mM][bB]?$/) {
  $opt{pagesize} = 5;
}

if(not ($opt{pagesize} == 0 or $opt{pagesize} == 1 or
	$opt{pagesize} == 3 or $opt{pagesize} == 5))
  {
    pod2usage(-exitval => 2,
	      -message =>
	      "Illegal value of parameter 'pagesize': '$opt{pagesize}'",
	      -verbose => 1);
  }



if(not is_pow2($opt{lenbytes})) {
  pod2usage(-exitval => 2,
	    -message =>
	    "lenbytes ($opt{lenbytes}) is not a power-of-2.",
	    -verbose => 1);
}

if(not is_pow2($opt{stride})) {
  pod2usage(-exitval => 2,
	    -message =>
	    "stride ($opt{stride}) is not a power-of-2.",
	    -verbose => 1);
}


my $num_chase = int($opt{lenbytes} / $opt{stride});

:#include "boot.s"
:
:.global main
:main:

if($opt{warmup}) {

  if($opt{disablel1_warmup}) {
:	call disable_l1d
:	nop
  }

  if($opt{warmup_loopback}) {
:	setx	loopback,	%o1,	%o0
  } else {
:	setx	chase_array,	%o1,	%o0
  }
:	call chase
:	nop

  if($opt{flush_dtlb}) {
:	call demap_dmmu_primary
:	nop
  }

  if($opt{disablel1_warmup}) {
:	call enable_l1d
:	nop
  }
}

:	setx	chase_array,	%o1,	%o0
:	call chase
:	nop
:	ta T_GOOD_TRAP
:	nop
:
:

:.global chase
:chase:

write_chase_func($num_chase, 'chase_array', 'chase');

:	nop
:	retl
:	nop

:
:
:

if($opt{warmup}) {

:SECTION USER_HPRIV TEXT_VA=0x20080000
:
:attr_text {
:  Name=USER_HPRIV,
:  RA=0x20080000,
:  PA=ra2pa(0x20080000,$opt{partition}),
:  part_$opt{partition}_i_ctx_nonzero_ps0_tsb, tte_cp=1, tte_cv=1,
:  tte_context=0x44, tte_v=1, tte_size=0
:}
:
:attr_text {
:  Name=USER_HPRIV,
:  hypervisor,
:}
:
  if($opt{disablel1_warmup}) {
:.global disable_l1d
:disable_l1d:
:	ta T_CHANGE_HPRIV
:	nop
:
:	ldxa	[%g0] ASI_LSU_CTL_REG,	%o0
:
:	setx	0xfffffffffffffffd, %o2, %o1
:	and	%o0,	%o1,	%o0
:
:mom_disable_l1d:
:	stxa	%o0,	[%g0] ASI_LSU_CTL_REG
:
:	ta T_CHANGE_NONHPRIV
:	nop
:	retl
:	nop
:
:
:.global enable_l1d
:enable_l1d:
:	ta T_CHANGE_HPRIV
:	nop
:
:	ldxa	[%g0] ASI_LSU_CTL_REG,	%o0
:
:	setx	0x2, %o2, %o1
:	or	%o0,	%o1,	%o0
:
:mom_enable_l1d:
:	stxa	%o0,	[%g0] ASI_LSU_CTL_REG
:
:	ta T_CHANGE_NONHPRIV
:	nop
:	retl
:	nop
:
  }
:
:.global demap_dmmu_primary
:demap_dmmu_primary:
:	ta T_CHANGE_HPRIV
:	nop
:
:! Set bit 6 (type=1 => demap context)
:	setx	0x40, %o1, %o0
:
:	stxa	%o0,	[%o0] ASI_DMMU_DEMAP
:
:	ta T_CHANGE_NONHPRIV
:	nop
:	retl
:	nop
}


:
:SECTION CHASEDATA DATA_VA=$opt{startva}
:
:attr_data {
:  Name=CHASEDATA,
:  RA=$opt{startra},
:  PA=ra2pa($opt{startra}, $opt{partition}),
:  part_$opt{partition}_d_ctx_nonzero_ps0_tsb,
:  tte_context=0x44, tte_v=1, tte_cp=1, tte_cv=1,
:  tte_size=$opt{pagesize},
:}
:
:.data
:.global chase_array
:chase_array:

my $next =
  generate_data($opt{lenbytes}, $opt{stride}, $opt{offset}, $opt{startva});

:.global loopback
:loopback:
:	.xword 0x$next
:
:
:
:

generate_perl_script(\%opt, $num_chase);


exit(0);

###############################################################################
###############################################################################

sub spec_to_int {
  my $spec = shift;
  my $paramname = shift;

  if($spec =~ /^0x([\dA-Fa-f]+)/) {
    return hex $spec;
  } elsif($spec =~ /^(\d+)[kK]/) {
    return $1 * 1024;
  } elsif($spec =~ /^(\d+)[mM]/) {
    return $1 * 1024 * 1024;
  } elsif($spec =~ /^\d+$/) {
    return $spec;
  }

  pod2usage(-exitval => 2,
	    -message => "Illegal value of parameter '$paramname': '$spec'",
	    -verbose => 1);
}

###############################################################################

sub generate_data {
  my $lenbytes = shift;
  my $stride   = shift;
  my $offset   = shift;
  my $startva  = shift;

  my $numentries = int($lenbytes / $stride);

  # Add an extra so we can hit the first one outside of the timing section
  # to cause a TLB fault before the TLB miss happens.  Add another to test
  # pipelined version
  $numentries += 2;

  my $va_bf = BitFieldTie->new(64, $startva);
  my $start_va_bf = $va_bf->new();

  my $cum_offset = 0;

  $va_bf->add($stride);

  foreach my $entrynum (0 .. $numentries-1) {
    if($entrynum == $numentries-1) {
:	.xword 0x$start_va_bf
    } else {
      my $next_va = BitFieldTie->new(64, $va_bf);
      $next_va->add($cum_offset);
:	.xword 0x$next_va
    }
:.align $stride
  if($cum_offset != 0) {
:.skip $cum_offset
  }

    $cum_offset += $offset;
    if($cum_offset >= $stride) {
      $cum_offset = 0;
    }

    $va_bf->add($stride);
  }

  my $next_va = BitFieldTie->new(64, $va_bf);
  $next_va->subtract($stride);
  return $next_va;
}

###############################################################################

sub write_chase_func {
  my $num   = shift;
  my $array = shift;
  my $funcname = shift;

# cause first TLB-miss so timed section doesn't
:	ldx	[%o0],	%o0

  if(defined $funcname) {
:${funcname}_start:
  }

  foreach (0 .. $num-1) {
:	ldx	[%o0],	%o0
  }

  if(defined $funcname) {
:${funcname}_end:
  }

# Add one more so end timing gets accurate value
:	ldx	[%o0],	%o0


}

###############################################################################

sub is_pow2 {
  my $num = shift;

  foreach my $i (0 .. 31) {
    my $test = 1 << $i;
    if($test == $num) {
      return 1;
    }
  }

  return 0;
}

###############################################################################

sub generate_perl_script {
  my $opt = shift;
  my $num_chase = shift;


:__PERL__
:
:

my $script =
qq{use strict;
use TRELoad 'AnalyzeDiag';

verbose(0);

my \$dir = '.';

my \$analyzer = AnalyzeDiag::Analyzer->new(dir => \$dir);

\$analyzer->add_measurements
  (
   AnalyzeDiag::Measurement->new(name  => 'PointerChase',
				 start => 'chase_start',
				 end   => 'chase_end')
  );
my \%results = \$analyzer->analyze();
						
my \@times = \@{ \$results{PointerChase} };

# divide by number of loads;
\@times = map { sprintf "%0.2f", (\$_ / $num_chase) } \@times;

script_say "Warmup: \$times[0]\\n";
script_say "Timing: \$times[1]\\n";

};

  if($opt{check} and $opt{expect_time}) {

    my $string =
      defined $opt{expect_string} ? $opt{expect_string} :
	'event';

    my $tol = $opt{tolerance};

    $script .=
qq{diag_is_numeric(scalar(\@times), 2, "Found 2 chases");
diag_is_numeric(\$times[1], $opt{expect_time}, \'$string\', $tol);
};
  };

$script .=
qq{
script_exit;
};


  my @lines = split /\n/, $script;
  foreach my $line (@lines) {
    chomp $line;
:$line
  }

}

###############################################################################
__END__

=head1 NAME

chase.pal - pointer-chasing diag generator

=head1 SYNOPSIS

  pal chase.pal [options] > chasingdiag.s

=head1 DESCRIPTION

This is a pal script used to generate pointer-chasing diags.

=head2 Options

The pal script recognizes the following options

=over 4

=item -lenbytes E<lt>lengthE<gt>

Length of the array to stride through in bytes.  Accepts hex or
decimal with optional suffixes k,K,m or M.  Default = 8k.

=item -stride E<lt>lengthE<gt>

Length of stride for array.  Accepts hex or decimal with optional
suffixes k,K,m, or M.  Default = 16.

=item -startva E<lt>VAE<gt>

VA for array in the diag.  Default=0x100000.

=item -startra E<lt>RAE<gt>

RA for array in the diag.  Default=0x10100000.

=item -partition E<lt>partition_idE<gt>

Partition to use when setting up diag.  Default=0.

=item -pagesize E<lt>page_sizeE<gt>

Page size bits for setting up the array.  Should be 0 (8k), 1 (64K), 3
(4M), or 5 (256M).  Also accepts the strings 8k, 64k, 4m, and 256m
(case-insensitive, with an optional 'B' at the end).

=item -chasefunc E<lt>functionE<gt>

Name of of the function to create that has the pointer chase.

=item -warmup / -nowarmup

Stride through the array once to warm up the L2 cache before
proceeding.  Default is -warmup.

=item -disablel1_warmup / -nodisablel1_warmup

When doing a warmup-pass, disable the L1 cache first.  Default is
-disablel1_warmup.

=item -check / -nocheck

Compare the cyc/load time for the timing run against an expected value.
Default is -check.

=item -expect_time E<lt>cyclesE<gt>

When doing the above check, use this value as the expected time in
cycles.  If not specified, no check is done.

=item -expect_string E<lt>stringE<gt>

Just a string used to enhance the readability of the output.  Labels
the parameter being measured by -check.

=item -tolerance E<lt>cyclesE<gt>

When doing check, make sure the time is within the specified tolerance
of the expected time.  Deafult = 0.

=back

=head1 SEE ALSO

pal(1).

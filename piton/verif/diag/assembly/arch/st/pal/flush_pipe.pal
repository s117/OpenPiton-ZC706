:!!
:
:#define H_T0_Tag_Overflow my_tag_overflow
:#include "boot.s"
:
:.text
:.global main
:.global interrupt_handler
:
:main:
:/*
: *****************************************************
: *
: *  This diag will test the flush_pipe signal and
: *  whether it kills all the proper instructions.
: *****************************************************
: */
:
: !! Traps are generated by a tagged overflow.  The trap handler
: !! is overridden to skip the next 4 instructions (those that 
: !! are supposed to be killed by the trap).  The tagged overflow
: !! is used because it probably isnt used by the boot code and so
: !! the trap handler can be customized.
: !! 
: !! The following cases are checked:
: !! 1) Make sure that the prior instructions are not killed
: !! 2) Test that normal integer ops and traps (div by zero and tagged overflow) 
: !!    are killed properly
: !!    by putting instructions of all categories in the 4 slots
: !!    behind a ta instruction.
: !! 3) Test killing of ifu ops and traps (br, illegal instruction, ITLB miss, tcc)
: !! 4) Test killing of LSU ops and traps (ld/st, DTLB miss)
: !! 5) Test that fp ops are killed properly (move, add, ld/st)
: !! 6) Test that window management instructions and traps are killed
: !! 7) Make sure an interrupt gets killed.
: !! 
: !! Everything gets executed twice to make sure it is in the icache.

: setx load_data, %g6, %g7
: set 8192, %g6 !! page offset
: ldx [%g7], %g0 !! get address into TLB
: !! Use %l5 to keep track of iteration
: mov 5, %l5
: !! 1) Make sure that the prior instructions are not killed
:   add %g0, 5, %l0
:   add %l0, 3, %l0
:   ta T_CHANGE_PRIV
:   nop
: flush_pipe_loop:
: !! 2) Test that normal integer ops are killed properly
: !!    by putting instructions of all categories in the 4 slots
: !!    behind a ta instruction.
: !! 3) Test killing of ifu ops and traps (br, illegal instruction, ITLB miss)
: !! 4) Test killing of LSU ops and traps (ld/st, DTLB miss)
: !! 5) Test that fp ops are killed properly
@ops = ("addcc %l0, 1, %l0",
        'mulscc %l0, 1, %l0',
        'udivcc %l0, 2, %l1',
        'umulcc %l0, 2, %l0',
        'udiv %g0, %g0, %g1',
        'taddcctv %g0, 1, %g1',
  # writes to status and priv registers
        'wr %g0, 0x3, %ccr',
        'wr %g0, 0x3, %y',
        'wr %g0, 0x3, %asi',
        'wr %g0, 0x3, %fprs',
        'wrpr %g0, 0x3, %cwp',
        'wrpr %g0, 0x2, %cansave',
        'wrpr %g0, 0x2, %canrestore',
        'wrpr %g0, 0x2, %canrestore',
        'wrpr %g0, 2, %tpc',
        'wrpr %g0, 2, %tnpc',
        'wrpr %g0, 2, %tstate',
        'wrpr %g0, 2, %tt',
        'wrpr %g0, 2, %tl',
        'wrpr %g0, 2, %tick',
        'wrpr %g0, 2, %pstate',
        'wrpr %g0, 2, %pil',
  # IFU instructions and traps
        'ba diag_fail',
        'call diag_fail',
        '.word 0x00c80801     !! brz  %g0, 154000 (illegal instruction)',
        'ba other_page !! cause immu miss',
        'ta T_BAD_TRAP',
  # LSU instructions and traps
        'ldx [%g7], %g5',
        'stx %g0, [%g7+8] !! store zero',
        'ldx [%g7+%g6], %g5  !! cause TLB miss',
        'done',
        'retry',
  # FP instructions
        'ldd [%g7], %f0',
        'std %f0, [%g7+8]',
        'fmovs %f0, %f1',
        'fadds %f0, %f1, %f2',
        'fmovsa %icc, %f0, %f1'
        );
for($inst_num = 0; $inst_num < @ops; $inst_num++) {
  for($slot = 0; $slot < 4; $slot++) {
:
:   # Set up status reg values
:   wr %g0, 0xFF, %ccr
:   wr %g0, 0xAA, %y
:   taddcctv %g0, 1, %g1 !! always traps and will skip nops and test instruction
    # Insert leading nops for padding
    for($i = 0; $i < $slot; $i++) {
:   nop
    }
    #Insert test operation
:   $ops[$inst_num]
    # Insert trailing nops for padding
    for($i = $slot + 1; $i < 4; $i++) {
:   nop
    }
:   # check that memory has not been written incorrectly
:   ldx [%g7+8], %g5
  }
}
:
: !! 3) Test that window management instructions and traps are killed
:
@setup = ("#Clean save\n wrpr %g0,5,%cansave\n wrpr %g0,2,%canrestore\n wrpr %g0,7,%cleanwin\n wrpr %g0,0,%otherwin",
          "#Restore\n wrpr %g0,5,%cansave\n wrpr %g0,2,%canrestore\n wrpr %g0,7,%cleanwin\n wrpr %g0,0,%otherwin",
          "#Spill trap\n wrpr %g0, %g0, %cansave\n wrpr %g0, 5, %canrestore\n wrpr %g0,7,%cleanwin\n wrpr %g0,0,%otherwin",
          "wrpr %g0,5,%cansave\n wrpr %g0,2,%canrestore\n wrpr %g0,7,%cleanwin\n wrpr %g0,0,%otherwin",
          "wrpr %g0,5,%cansave\n wrpr %g0,2,%canrestore\n wrpr %g0,7,%cleanwin\n wrpr %g0,0,%otherwin",
          "wrpr %g0,5,%cansave\n wrpr %g0,2,%canrestore\n wrpr %g0,7,%cleanwin\n wrpr %g0,0,%otherwin"
          );
@ops = ('save %l0, 3, %l0',
        'restore %l0, 3, %l0',
        "save %l0, 3, %l0",
        'saved',
        'restored',
        'wrpr %g0, 0x1, %cwp');
for($inst_num = 0; $inst_num < @ops; $inst_num++) {
  for($slot = 0; $slot < 4; $slot++) {
:
:   # Set up window management values
:   wrpr %g0, 0x0, %cwp
:   $setup[$inst_num]
:   taddcctv %g0, 1, %g1
    # Insert leading nops for padding
    for($i = 0; $i < $slot; $i++) {
:   nop
    }
    #Insert test operation
:   $ops[$inst_num]
    # Insert trailing nops for padding
    for($i = $slot + 1; $i < 4; $i++) {
:   nop
    }
:   add %l0, 1, %l0
  }
}
:
:
: !! 7) Make sure an interrupt gets killed.
: !!  It takes ~6 cycles to get the interrupt into the pipeline
: !!  so the interrupt task will be swept from 0-8 cycles before the
: !!  trapping instruction.
for($slot= 0; $slot < 9; $slot++) {
:intr_marker$slot:
:   nop     ! $EV trig_pc_d (1,\@VA(.RED_SEC.intr_marker$slot)) -> intp(0, 0, 5)
  for($i = 0; $i < $slot; $i++) {
:   nop
  }
:   !! trapping instruction
:   taddcctv %g0, 1, %g1
:   nop
:   nop
:   nop
:   nop
:   nop
:   nop
}
: brnz %l5, flush_pipe_loop
: mov %g0, %l5
:
: !! All done!!
: ba diag_pass
: nop
:
:/*
: ********************************
: *      trap handler            *
: ********************************
: */
:interrupt_handler:      
:        ldxa  [ %g0 ] 0x7F, %g3  !! read interrupt vector from ASI_UDB_INTR_R
:   retry
:   nop
:
:/*
: ********************************
: *      Diag PASSED             *
: ********************************
: */
:diag_pass:
:        set     0xaaddcafe,     %l0
:        ta T_GOOD_TRAP
:        nop
:
:
:/*
: ********************************
: *      Diag FAILED             *
: ********************************
: */
:diag_fail:
:        set     0xdeadbeef,     %l0
:        ta T_BAD_TRAP
:        nop
:
: !! New page to cause immu miss
:.align 8192
:other_page:
: ba diag_fail
: nop
:
:.data
:load_data:
:  .word 0x11223344, 0x55667788
:  .word 0xdeadbeef, 0xaaddcafe
:.end
:
:SECTION .USER_TRAP_FOR_SUP TEXT_VA=0x20008000
:attr_text {
:        Name = .USER_TRAP_FOR_SUP,
:        RA=0x20008000,
:        PA=ra2pa(0x20008000,0),
:        part_0_i_ctx_zero_ps0_tsb,
:        TTE_G=1, TTE_Context=0, TTE_V=1, TTE_Size=0x0, TTE_NFO=0,
:        TTE_IE=0, TTE_Soft2=0, TTE_Diag=0, TTE_Soft=0,
:        TTE_L=0, TTE_CP=1, TTE_CV=0, TTE_E=0, TTE_P=1, TTE_W=0
:        }
:
:
:   # This skips over the next 4 instructions so the instruction getting 
:   # tested should never actually get executed.  It also makes sure that
:   # the locals are correct (no problems with window swaps).
:.global my_tag_overflow
:my_tag_overflow:
:   rdpr %tpc, %g1
:   add %g1, 16, %g1
:   wrpr %g0, %g1, %tpc
:   rdpr %tnpc, %g1
:   add %g1, 16, %g1
:   wrpr %g0, %g1, %tnpc
:   add %l0, 2, %l0
:   done
:   nop

